<!DOCTYPE html>
<html>
<head >
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script>
    //闭包虽然好，但不建议过多使用，因为每使用一次都会形成一个不销毁的作用域。
    //自定义属性这个方法最好，不用获取前面的。（函数外的this都是window,我们研究this一般都研究函数里面的this指向问题）
    //->context上下文:当前方法执行的范围
    //->this执行的主体：谁来执行的这个方法
    //你以为你以为的就是你以为的：
    //->函数中的this是谁，和函数在哪定义的、和函数在哪执行的，都没有半毛钱关系
    //1)只要是自执行函数执行，那么方法中的this就是window
    //2)给元素的某一个事件绑定方法，方法执行的时候，里面的this是当前元素本身
    //3)方法名（）->这个是在执行方法，想知道方法中的this是谁，只需要看方法名前面是否有“.”,有的话，"."前面是谁，this就是谁，没有的话this就是window
    //单例模式（起到了分组的作用）中：就是一个对象，在单例模式中，person1/person2叫做命名空间->我们防止名字相同时候的冲突，把每一个事物都看成一个单独的个体，把描述这件事物的属性放在同一个命名空间下，以后通过不同的命名空间来区分不同的实例

    //工厂模式：不用像之前的单例模式一个个的写了，只需要开一个工厂，实现批量化的生产即可
    //把实现一个功能的代码封装到一个函数中，以后再想实现这个功能，，不需要重新的编写这些代码了，只需要执行这个函数即可->"类（函数）的封装"：（低耦合，高内聚）->减少页面中的冗余代码，提高的重复利用率
    //HTMLColeection(元素集合类，通过getElementsByTagName这些方法获取到的类数组集合都是这个类的一个实例)
    //NodeList(节点集合类，通过getElementsByName获取到的节点集合老师这个类的一个实例)
    //#div1->HTMLDivElement()


    //类的多态："后台语言"中的多态是一个类的多种形态，包含了：重载和重写

    //[重载]：后台语言中指的是多个方法，他们的方法名相同，但是参数（多少个、类型、顺序）或者返回值不同
    //JS中严格意义的来说没有重载，但是放松来说有一个模式和重载类似：一个方法通过传递参数的不同，方法最后处理的结果也不一样，我们也可以把它理解为重载

    //[重写]
    //JS中也有重写：子类重写父类的方法
    //this的第四种情况：
    //在构造函数模式执行的时候，方法体中的this就是当前这个类的一个实例

    //类：所有的类的都是函数数据类型的

    //->在使用new执行函数的时候，如果Fn不需要传递参数的话，我们后面的小括号可以加也可以不加

    //实例：所有的实例都是对象数据类型的

</script>
</body>
</html>